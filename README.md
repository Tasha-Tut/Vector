## Vector
 В этом задании рассмотрен класс std::vector, являющийся обобщением динамической строки на произвольный тип, то есть класс динамического массива.
 
### Детали реализации
Реализован шаблонный класс Vector с единственным шаблонным параметром - типом хранящихся элементов.
При реализации используются обобщенными алгоритмы из STL (std::copy, std::fill и т.п.), но не используются
стандартные контейнеры. Реализована мультипликативная схема расширения массива с коэффициентом 2. 
В базовой версии ручное управление временем жизни объектов не требуется (см. #define VECTOR_MEMORY_IMPLEMENTED). Класс поддерживает следующий функционал:
- Конструктор по умолчанию - создает пустой массив;
- Явный конструктор от числа - создает массив заданного размера заполненный объектами, сконструированными по умолчанию;
- Конструктор, принимающий size и value (именно в этом порядке) - создает массив длины size, заполненный элементами со значением value;
- Шаблонный конструктор, принимающий пару итераторов - создает копию переданного диапазона;
- Конструктор от std::initializer_list;
- Правило "пяти";
- Методы Size, Capacity, Empty;
- Константный и неконстантный оператор доступа по индексу []. Неконстантный должен позволять изменять полученный элемент;
- Константный и неконстантный метод доступа по индексу At. При выходе за границы массива должен бросать исключение std::out_of_range;
- Методы Front() и Back()
  - доступ к первому и последнему элементам (тоже по две версии).
- Метод Data()
  - возвращает указатель на начало массива.
- Метод Swap(other)
  - обменивает содержимое с другим массивом other;
- Метод Resize(new_size)
  - изменяет размер на new_size. Если вместимость не позволяет хранить столько элементов, то выделяется новый буфер с вместимостью new_size. Недостающие элементы конструируются по умолчанию.
- Метод Resize(new_size, value)
  - то же, что и Resize(new_size), но в случае new_size > size заполняет недостающие элементы значением value.
- Метод Reserve(new_cap)
  - изменяет вместимость на max(new_cap, текущая вместимость). Размер при этом не изменяется.
- Метод ShrinkToFit()
  - уменьшает capacity до size.
- Метод Clear()
  - устанавливает размер в 0, очищения выделенной памяти при этом НЕ происходит.
- Методы PushBack(const T&) и PushBack(T&&)
  - добавляет новый элемент в конец массива.
- Метод PopBack()
  - удаляет последний элемент.
- Операции сравнения (<, >, <=, >=, ==, !=), задающие лексикографический порядок.

Также реализована поддержка итераторов и методов для работы с ними: begin(), end(), cbegin(), cend(), rbegin(), rend(),
crbegin(), crend(). begin()-end(), rbegin()-rend() имеют две версии, возвращающие константные и неконстантные итераторы.

Внутри класса Vector определины типы-члены ValueType, Pointer, ConstPointer, Reference, ConstReference, SizeType, Iterator, ConstIterator.

Гарантии безопасности
Спроектируйте класс так, чтобы при возникновении исключений (нехватка памяти, ошибка при копировании объектов и т.п.) методы удовлетворяли
строгой гарантии безопасности. То есть все методы должны работать атомарно: либо работать без сбоев, либо не изменять исходного состояния вектора.
Исключение: копирующее присваивание может давать лишь базовую гарантию безопасности. Предполагается, что конструкторы перемещения, перемещающие присваивания и деструкторы объектов никогда не бросают исключений!

#define VECTOR_MEMORY_IMPLEMENTED означает, что:
в каждый момент времени существует ровно size объектов. При добавлении элементов (например, с помощью PushBack, либо Resize) новые элементы
создаются вручную с помощью placement new, а при удалении элемента (например, с помощью PopBack или Clear) для него вручную вызывается деструктор 
(либо std::destroy и std::destroy_at). При решении используются алгоритмы стандартной библиотеки для работы с неинициализированной памятью (секция uninitialized storage).
